package schema

import (
	"fmt"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/oapi-codegen/v2/pkg/globalstate"
)

func composeGoSchemaForEnum(schema *openapi3.Schema, t *openapi3.Types, outSchema *Schema, path []string) (Schema, error) {
	err := oapiSchemaToGoType(schema, path, outSchema)
	// Enums need to be typed, so that the values aren't interchangeable,
	// so no matter what schema conversion thinks, we need to define a
	// new type.
	outSchema.DefineViaAlias = false

	if err != nil {
		return Schema{}, fmt.Errorf("error resolving primitive type: %w", err)
	}
	enumValues := make([]string, len(schema.Enum))
	for i, enumValue := range schema.Enum {
		enumValues[i] = fmt.Sprintf("%v", enumValue)
	}

	enumNames := enumValues
	for _, key := range []string{extEnumVarNames, extEnumNames} {
		if extension, ok := schema.Extensions[key]; ok {
			if extEnumNames, err := extParseEnumVarNames(extension); err == nil {
				enumNames = extEnumNames
				break
			}
		}
	}

	sanitizedValues := SanitizeEnumNames(enumNames, enumValues)
	outSchema.EnumValues = make(map[string]string, len(sanitizedValues))

	for k, v := range sanitizedValues {
		var enumName string
		if v == "" {
			enumName = "Empty"
		} else {
			enumName = k
		}
		if globalstate.GlobalState.Options.Compatibility.OldEnumConflicts {
			outSchema.EnumValues[SchemaNameToTypeName(PathToTypeName(append(path, enumName)))] = v
		} else {
			outSchema.EnumValues[SchemaNameToTypeName(k)] = v
		}
	}
	if len(path) > 1 { // handle additional type only on non-toplevel types
		// Allow overriding autogenerated enum type names, since these may
		// cause conflicts - see https://github.com/oapi-codegen/oapi-codegen/issues/832
		var typeName string
		if extension, ok := schema.Extensions[extGoTypeName]; ok {
			typeName, err = extString(extension)
			if err != nil {
				return *outSchema, fmt.Errorf("invalid value for %q: %w", extGoTypeName, err)
			}
		} else {
			typeName = SchemaNameToTypeName(PathToTypeName(path))
		}

		typeDef := TypeDefinition{
			TypeName: typeName,
			JsonName: strings.Join(path, "."),
			Schema:   *outSchema,
		}
		outSchema.AdditionalTypes = append(outSchema.AdditionalTypes, typeDef)
		outSchema.RefType = typeName
	}
	return *outSchema, nil
}
